nginx

第一点 nginx 是进程的 一个daemon 多个work  work 数和cpu 核心数相同保证cpu的亲和性
跨线程切换上下文的开销是很大的 保存现场 然后准备新线程所需要的数据 运行新线程 还有 内核态和
用户态的切换也出现再上下文切换的过程中

现在，我们知道了当我们在操作 Nginx 的时候，Nginx 内部做了些什么事情，那么，worker 进程又是如何处理
请求的呢？我们前面有提到，worker 进程之间是平等的，每个进程，处理请求的机会也是一样的。当我们提供 8
0 端口的 http 服务时，一个连接请求过来，每个进程都有可能处理这个连接，怎么做到的呢？首先，每个 worke
r 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）之
后，然后再 fork 出多个 worker 进程。所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一
个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册
listenfd 读事件，在读事件里调用 accept 接受该连接。当一个 worker 进程在 accept 这个连接之后，
就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样
的了。我们可以看到，一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。


关于同步异步的问题 就是server 对你的响应时间 比如我有一个请求服务器忙就会存在一个消息队列里面
你先去干别的事情不必等着 描述的是一个分布式系统的消息通信机制

阻塞非阻塞说的是进程 或者线程在请求cpu 计算资源的过程中遇到等待的问题
